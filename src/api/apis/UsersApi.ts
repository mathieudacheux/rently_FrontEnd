// tslint:disable
/**
 * Api documentation
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { QueryConfig, ResponseBody } from 'redux-query'
import {
  UserSerializerPost,
  UserSerializerPostToJSON,
  UserSerializerPut,
  UserSerializerPutToJSON,
  UserSerializerRead,
  UserSerializerReadFromJSON,
} from '../models'
import * as runtime from '../runtime'

export interface UsersDeleteUserRequest {
  id: number
}

export interface UsersGetAllUsersRequest {
  page?: number
}

export interface UsersGetUserByIdRequest {
  id: number
}

export interface UsersGetUsersByFilterRequest {
  mail?: string
  phone?: string
  name?: string
  firstname?: string
  city?: string
  zipcode?: string
}

export interface UsersSignupUserRequest {
  userSerializerPost?: UserSerializerPost
}

export interface UsersUpdateUserRequest {
  id: number
  userSerializerPut?: UserSerializerPut
}

/**
 * Delete a user by its id
 */
function usersDeleteUserRaw<T>(
  requestParameters: UsersDeleteUserRequest,
  requestConfig: runtime.TypedQueryConfig<T, void> = {},
): QueryConfig<T> {
  if (requestParameters.id === null || requestParameters.id === undefined) {
    throw new runtime.RequiredError(
      'id',
      'Required parameter requestParameters.id was null or undefined when calling usersDeleteUser.',
    )
  }

  let queryParameters = null

  const headerParameters: runtime.HttpHeaders = {}

  const { meta = {} } = requestConfig

  meta.authType = ['bearer']
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/users/{id}`.replace(
      `{${'id'}}`,
      encodeURIComponent(String(requestParameters.id)),
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'DELETE',
      headers: headerParameters,
    },
    body: queryParameters,
  }

  const { transform: requestTransform } = requestConfig
  if (requestTransform) {
  }

  return config
}

/**
 * Delete a user by its id
 */
export function usersDeleteUser<T>(
  requestParameters: UsersDeleteUserRequest,
  requestConfig?: runtime.TypedQueryConfig<T, void>,
): QueryConfig<T> {
  return usersDeleteUserRaw(requestParameters, requestConfig)
}

/**
 * Return a list of all users
 */
function usersGetAllUsersRaw<T>(
  requestParameters: UsersGetAllUsersRequest,
  requestConfig: runtime.TypedQueryConfig<T, Array<UserSerializerRead>> = {},
): QueryConfig<T> {
  let queryParameters = null

  queryParameters = {
    page: requestParameters.page,
  }

  const headerParameters: runtime.HttpHeaders = {}

  const { meta = {} } = requestConfig

  meta.authType = ['bearer']
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/users`,
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'GET',
      headers: headerParameters,
    },
    body: queryParameters,
  }

  const { transform: requestTransform } = requestConfig
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(body.map(UserSerializerReadFromJSON), text)
  }

  return config
}

/**
 * Return a list of all users
 */
export function usersGetAllUsers<T>(
  requestParameters: UsersGetAllUsersRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Array<UserSerializerRead>>,
): QueryConfig<T> {
  return usersGetAllUsersRaw(requestParameters, requestConfig)
}

/**
 * Return a user by his id
 */
function usersGetUserByIdRaw<T>(
  requestParameters: UsersGetUserByIdRequest,
  requestConfig: runtime.TypedQueryConfig<T, UserSerializerRead> = {},
): QueryConfig<T> {
  if (requestParameters.id === null || requestParameters.id === undefined) {
    throw new runtime.RequiredError(
      'id',
      'Required parameter requestParameters.id was null or undefined when calling usersGetUserById.',
    )
  }

  let queryParameters = null

  const headerParameters: runtime.HttpHeaders = {}

  const { meta = {} } = requestConfig

  meta.authType = ['bearer']
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/users/{id}`.replace(
      `{${'id'}}`,
      encodeURIComponent(String(requestParameters.id)),
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'GET',
      headers: headerParameters,
    },
    body: queryParameters,
  }

  const { transform: requestTransform } = requestConfig
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(UserSerializerReadFromJSON(body), text)
  }

  return config
}

/**
 * Return a user by his id
 */
export function usersGetUserById<T>(
  requestParameters: UsersGetUserByIdRequest,
  requestConfig?: runtime.TypedQueryConfig<T, UserSerializerRead>,
): QueryConfig<T> {
  return usersGetUserByIdRaw(requestParameters, requestConfig)
}

/**
 * Return a list of users by filter
 */
function usersGetUsersByFilterRaw<T>(
  requestParameters: UsersGetUsersByFilterRequest,
  requestConfig: runtime.TypedQueryConfig<T, Array<UserSerializerRead>> = {},
): QueryConfig<T> {
  let queryParameters = null

  queryParameters = {
    mail: requestParameters.mail,
    phone: requestParameters.phone,
    name: requestParameters.name,
    firstname: requestParameters.firstname,
    city: requestParameters.city,
    zipcode: requestParameters.zipcode,
  }

  const headerParameters: runtime.HttpHeaders = {}

  const { meta = {} } = requestConfig

  meta.authType = ['bearer']
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/users/users_filter`,
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'GET',
      headers: headerParameters,
    },
    body: queryParameters,
  }

  const { transform: requestTransform } = requestConfig
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(body.map(UserSerializerReadFromJSON), text)
  }

  return config
}

/**
 * Return a list of users by filter
 */
export function usersGetUsersByFilter<T>(
  requestParameters: UsersGetUsersByFilterRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Array<UserSerializerRead>>,
): QueryConfig<T> {
  return usersGetUsersByFilterRaw(requestParameters, requestConfig)
}

/**
 * Create a new user
 */
function usersSignupUserRaw<T>(
  requestParameters: UsersSignupUserRequest,
  requestConfig: runtime.TypedQueryConfig<T, UserSerializerRead> = {},
): QueryConfig<T> {
  let queryParameters = null

  const headerParameters: runtime.HttpHeaders = {}

  headerParameters['Content-Type'] = 'application/json'

  const { meta = {} } = requestConfig

  meta.authType = ['bearer']
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/users`,
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'POST',
      headers: headerParameters,
    },
    body:
      queryParameters ||
      UserSerializerPostToJSON(requestParameters.userSerializerPost),
  }

  const { transform: requestTransform } = requestConfig
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(UserSerializerReadFromJSON(body), text)
  }

  return config
}

/**
 * Create a new user
 */
export function usersSignupUser<T>(
  requestParameters: UsersSignupUserRequest,
  requestConfig?: runtime.TypedQueryConfig<T, UserSerializerRead>,
): QueryConfig<T> {
  return usersSignupUserRaw(requestParameters, requestConfig)
}

/**
 * Update a user by its id
 */
function usersUpdateUserRaw<T>(
  requestParameters: UsersUpdateUserRequest,
  requestConfig: runtime.TypedQueryConfig<T, UserSerializerRead> = {},
): QueryConfig<T> {
  if (requestParameters.id === null || requestParameters.id === undefined) {
    throw new runtime.RequiredError(
      'id',
      'Required parameter requestParameters.id was null or undefined when calling usersUpdateUser.',
    )
  }

  let queryParameters = null

  const headerParameters: runtime.HttpHeaders = {}

  headerParameters['Content-Type'] = 'application/json'

  const { meta = {} } = requestConfig

  meta.authType = ['bearer']
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/users/{id}`.replace(
      `{${'id'}}`,
      encodeURIComponent(String(requestParameters.id)),
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'PUT',
      headers: headerParameters,
    },
    body:
      queryParameters ||
      UserSerializerPutToJSON(requestParameters.userSerializerPut),
  }

  const { transform: requestTransform } = requestConfig
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(UserSerializerReadFromJSON(body), text)
  }

  return config
}

/**
 * Update a user by its id
 */
export function usersUpdateUser<T>(
  requestParameters: UsersUpdateUserRequest,
  requestConfig?: runtime.TypedQueryConfig<T, UserSerializerRead>,
): QueryConfig<T> {
  return usersUpdateUserRaw(requestParameters, requestConfig)
}
